# 운영체제 프로젝트 #2
가상 메모리(페이징)를 이용한 멀티프로세스 실행

**제출기한: 12월 4일 (2주)**

## 소개

이전 프로젝트에서는 다수의 프로세스가 동시에 실행될 수 있게 하는 스케줄링 시뮬레이션을 수행했습니다. 이를 기반으로, 이번에는 각 프로세스에 가상 메모리를 추가할 것입니다. 가상 메모리는 1) 프로그램 개발을 용이하게 하고, 2) 프로그램을 다른 악의적인 프로그램으로부터 보호할 수 있게 하는 중요한 개념입니다. 가상 메모리를 통해 각 프로세스는 마치 전체 메모리를 소유한 것처럼 메모리에 접근할 수 있습니다(실제로는 그렇지 않지만). 따라서 소프트웨어 엔지니어는 변수, 코드, 스택 등의 물리적 메모리 위치를 걱정할 필요가 없습니다. 대신 프로세스는 자신만의 주소 공간(프로세스가 가리킬 수 있는 주소의 집합)에서 실행됩니다. 주소 공간을 다루기 위해서는 페이징이나 세그멘테이션이라 불리는 가상 메모리를 위한 아키텍처적 지원이 필요합니다.

페이징은 물리 주소와 논리 주소(가상 주소) 사이의 주소 변환을 구현하는 개념입니다. 프로세스가 주소 공간에서 실행되기 위해서는 프로그램이 가상 주소로 작성되어야 합니다. 즉, CPU는 직접 가상 주소를 보게 됩니다. 반면에 컴퓨터는 실제 데이터의 위치(물리 주소)로 작동해야 합니다. OS는 가상 주소를 물리 주소로 매핑하는 테이블을 관리하므로, CPU는 가상 주소를 보지만 그에 해당하는 물리 주소에 접근하게 됩니다.

페이징은 페이지라는 개념을 중심으로 주소 공간을 정의합니다. 페이지는 주소 공간의 작은 부분집합입니다. 페이지를 실제 메모리 위치에 매핑하기 위해, 전체 메인 메모리를 페이지 프레임이라 불리는 작은 조각들로 나눕니다. 그러면 OS는 각 페이지를 페이지 프레임과 매핑합니다. 즉, 페이지는 주소 매핑의 단위입니다. 일반적인 32비트 컴퓨터에서 페이지의 크기는 4킬로바이트입니다. 즉, 4KB 크기의 주소 공간과 메모리 조각들이 매핑됩니다.

각 페이지 프레임은 정수로 번호가 매겨지며, 이 번호를 페이지 프레임 번호라고 합니다. 물리 주소에 따라 0부터 시작하는 번호가 매겨집니다(즉, 물리 메모리 주소 0~0xFFF, 0x1000~0x1FFF, 0x2000~0x2FFF, 0x3000~0x3FFF에 대해 각각 페이지 프레임 번호 0, 1, 2, 3, ...). OS는 VA를 PA로 매핑하는 페이지 테이블이라 불리는 테이블을 관리합니다.

## 구현 요구사항

### 1. 목표
페이징을 통한 주소 변환과 요구 페이징을 사용한 효율적인 페이지 테이블 관리를 이해합니다.
#### A. 시뮬레이터는 정확하게 작동해야 합니다
(중단되지 않아야 하며, VA->PA 변환이 커널에 의해 적절히 수행되어야 하고, OS는 런타임에 페이지 테이블을 업데이트해야 합니다)
#### B. 하나의 프로세스(부모 프로세스)는 커널로 동작하고, 다른 10개의 프로세스는 사용자 프로세스로 동작합니다

### 2. OS 초기화 시
#### A. 부팅 시
물리 메모리는 페이지 크기로 분할되어야 하며, OS는 free page frame 리스트(또는 간단히 free page 리스트)를 관리해야 합니다
#### B. 전체 물리 메모리 크기는 가정할 수 있습니다. PFN은 0부터 시작합니다

### 3. 사용자 프로세스 초기화 시
#### A. OS는 각 프로세스에 대한 페이지 테이블을 관리합니다
OS가 새로운 프로세스를 생성할 때, 비어있는 상태로 초기화된 페이지 테이블을 할당합니다

### 4. 사용자 프로세스 실행 시
#### A. 프로세스가 타임 슬라이스(틱)를 받으면
일부(10개) 메모리 주소(페이지)에 접근해야 합니다
##### i. 메모리 접근을 시뮬레이션하기 위해
사용자 프로세스는 10개 페이지에 대한 메모리 접근 요청을 포함하는 IPC 메시지를 보냅니다
#### B. 그러면 OS는 페이지 테이블을 확인합니다
##### i. 페이지 테이블 엔트리가 유효하면 PA에 접근합니다
##### ii. 페이지 테이블 엔트리가 유효하지 않으면
OS는 free page 리스트에서 새로운 free page frame을 가져옵니다. 그런 다음 페이지 테이블을 페이지 프레임 번호로 업데이트합니다
#### C. 페이지 테이블을 확인하기 위해
VM 주소를 VM 페이지 번호와 VM 페이지 오프셋 두 부분으로 나눠야 합니다
##### i. MMU는 페이지 테이블의 시작 주소를 가리킵니다
##### ii. VM 페이지 번호는 페이지 테이블 인덱스로 사용됩니다
##### iii. 페이지 테이블 인덱스에 페이지 테이블 엔트리가 위치합니다
##### iv. 페이지 테이블 엔트리 내부에는 페이지 프레임 번호와 FLAG도 저장됩니다

### 5. 추가 구현 (2단계 페이징)
#### A. 실제 페이지 사용률은 보통 낮습니다
따라서 대부분의 시간 동안 대부분의 페이지 테이블 엔트리는 0으로 채워져 있습니다
#### B. 페이지 테이블 크기를 최소화하기 위해
페이지 테이블 구조의 크기를 줄일 수 있습니다. 주소 비트는 1단계 VM 주소, 2단계 VM 주소, VM 페이지 오프셋으로 나뉩니다
#### C. MMU는 1단계 페이지 테이블을 가리킵니다
1단계 VM 주소는 1단계 페이지 테이블 인덱스로 사용됩니다. 2단계 VM 주소는 2단계 페이지 테이블 인덱스로 사용됩니다
#### D. 1단계 엔트리가 null이면 2단계 페이지 테이블은 존재하지 않습니다
1단계 페이지 테이블 폴트가 발생하면 OS는 free page frame을 할당합니다. 그런 다음 1단계 페이지 테이블 엔트리를 페이지 프레임 번호로 채웁니다
#### E. 다음으로 2단계 페이지 테이블에 접근합니다
그러면 다시 페이지 폴트가 발생합니다. OS가 페이지 폴트를 잡아서 다른 free page frame을 가져와서 페이지 테이블을 페이지 프레임 번호로 채웁니다
#### F. 프로세스가 완료되면
모든 페이지 테이블을 정리하고 사용된 메모리를 해제해야 합니다

### 6. 추가 구현 (스와핑)
#### A. 물리 메모리의 용량은 제한되어 있지만
가상 메모리 주소 공간은 물리 메모리보다 큽니다
#### B. OS에 free page frame이 부족할 때
메인 메모리의 일부 페이지 프레임을 보조 메모리(또는 디스크)로 이동하여 free page를 확보합니다
#### C. 메인 메모리에서 방출할 페이지를 선택하기 위해 LRU 알고리즘을 사용할 수 있습니다
LRU는 가장 적게 사용된 페이지를 선택합니다. 가장 적게 사용된 페이지를 선택하기 위해 각 페이지에 대한 카운터가 필요합니다
#### D. 페이지가 선택되면 디스크로 이동됩니다
무한한 디스크 크기를 가정할 수 있습니다. 디스크는 큰 파일로 가정됩니다. 메인 메모리의 활성 페이지와 백업 저장소의 수동 페이지를 구분하기 위해 추가 플래그 비트를 사용합니다. 디스크에 여러 페이지를 저장하기 위해 프로세스 ID, 페이지 번호를 페이지 데이터와 함께 저장해야 합니다. 간단히 하기 위해 페이지 데이터는 null로 가정할 수 있습니다
#### E. 스왑 아웃된 페이지에 접근하면
OS는 현재 프로세스를 중지하고 디스크에서 메인 메모리로 데이터를 이동하여 페이지 테이블을 다시 채웁니다. 페이지 프레임 번호는 이전과 다를 수 있습니다

### 7. 추가 구현 (Fork 시 Copy-on-write)
#### A. 실제 데이터로 페이징을 시뮬레이션할 수 있습니다
물리 메모리가 파일의 내용으로 채워져 있다고 가정할 수 있습니다(예: simple.bin). 처음에 모든 파일을 물리 메모리로 읽어들입니다. 사용자 프로세스가 메모리에 접근할 때 실제 데이터를 얻을 수 있습니다
#### B. 메모리 접근은 읽기 또는 쓰기입니다
읽기/쓰기를 시뮬레이션할 수 있습니다. 쓰기에는 쓸 데이터가 필요하고 읽기 요청은 읽은 데이터를 반환한다는 점에 유의하세요
#### C. 첫 번째 자식으로부터 fork를 시뮬레이션할 수 있습니다
10개의 자식 프로세스가 첫 번째 자식으로부터 fork된다고 가정할 수 있습니다. fork된 프로세스들(9개의 자식 프로세스)의 경우, 처음에는 주소 공간이 공유됩니다. 자식이 메모리를 변경할 때 별도의 PA를 사용하기 시작합니다. 메모리의 변경을 알리기 위해 자식 메모리는 읽기 전용으로 설정됩니다. 쓰기 시점에서 자식은 새로운 매핑을 생성합니다(새로운 페이지 프레임을 찾고 페이지 테이블을 설정합니다). 물리 페이지 프레임의 데이터는 부모에서 자식 페이지로 복사됩니다. 그런 다음 자식에서 쓰기 연산을 수행하여