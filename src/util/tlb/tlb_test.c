
/*

 Generated by Claude AI

*/

#include <stdio.h>
#include <assert.h>
#include "tlb.h"

// TLB 상태를 출력하는 헬퍼 함수
void print_tlb_state(tlb_t* tlb) {
    printf("\nCurrent TLB State:\n");
    printf("Index\tValid\tVPN\t\tFrame\tR/W\tU/S\tTimestamp\tSCA\n");
    printf("-----------------------------------------------------\n");
    for (int i = 0; i < TLB_SIZE; i++) {
        printf("%5d\t%5d\t0x%08x\t0x%08x\t%8d\t%8d\t%8u\t\t%8d\n",
               i,
               tlb->entries[i].valid,
               tlb->entries[i].vpn,
               tlb->entries[i].frame_number,
               tlb->entries[i].read_write,
               tlb->entries[i].user_supervisor,
               tlb->entries[i].timestamp,
               tlb->entries[i].sca);
    }
    printf("\n");
}

void test_tlb_initialization() {
    printf("\n=== Testing TLB Initialization ===\n");
    tlb_t tlb;
    initialize_tlb(&tlb);
    
    printf("Initial TLB state after initialization:\n");
    print_tlb_state(&tlb);
    
    // 모든 엔트리가 invalid로 초기화되었는지 확인
    for (int i = 0; i < TLB_SIZE; i++) {
        assert(tlb.entries[i].valid == 0);
    }
    printf("TLB initialization test passed\n");
}

void test_tlb_lookup_hit_miss() {
    printf("\n=== Testing TLB Lookup Hit/Miss ===\n");
    tlb_t tlb;
    initialize_tlb(&tlb);
    tlb.policy = FIFO;
    
    uint16_t vaddr = 0x1234;
    uint32_t paddr;
    uint32_t frame_number = 0x12;
    
    printf("Adding entry - Virtual Address: 0x%04x, Frame Number: 0x%02x\n", vaddr, frame_number);
    tlb_add_entry(&tlb, vaddr, frame_number, 1, 1);
    print_tlb_state(&tlb);
    
    // Hit 테스트
    printf("\nTesting TLB hit with address 0x%04x\n", vaddr);
    int result = tlb_lookup(&tlb, vaddr, &paddr);
    assert(result == TLB_HIT);
    printf("Hit successful! Physical address: 0x%08x\n", paddr);
    
    // Miss 테스트
    uint16_t miss_addr = 0x5678;
    printf("\nTesting TLB miss with address 0x%04x\n", miss_addr);
    result = tlb_lookup(&tlb, miss_addr, &paddr);
    assert(result == TLB_MISS);
    printf("Miss confirmed!\n");
    
    printf("TLB lookup hit/miss test passed\n");
}

void test_tlb_fifo_replacement() {
    printf("\n=== Testing FIFO Replacement ===\n");
    tlb_t tlb;
    initialize_tlb(&tlb);
    tlb.policy = FIFO;
    
    printf("Filling TLB with %d entries...\n", TLB_SIZE);
    // TLB를 가득 채움
    for (int i = 0; i < TLB_SIZE; i++) {
        uint16_t vaddr = i << 8;
        printf("Adding entry %d - Virtual Address: 0x%04x, Frame: %d\n", i, vaddr, i);
        tlb_add_entry(&tlb, vaddr, i, 1, 1);
    }
    
    printf("\nTLB state after filling:\n");
    print_tlb_state(&tlb);
    
    // 추가 엔트리를 넣어서 FIFO 교체 확인
    uint16_t new_vaddr = TLB_SIZE << 8;
    printf("\nAdding new entry to trigger FIFO replacement - VA: 0x%04x\n", new_vaddr);
    tlb_add_entry(&tlb, new_vaddr, TLB_SIZE, 1, 1);
    
    printf("\nTLB state after replacement:\n");
    print_tlb_state(&tlb);
    
    uint32_t paddr;
    assert(tlb_lookup(&tlb, 0, &paddr) == TLB_MISS);
    printf("Verified: First entry was replaced (TLB miss for VA: 0x0000)\n");
    assert(tlb_lookup(&tlb, new_vaddr, &paddr) == TLB_HIT);
    printf("Verified: New entry is present (TLB hit for VA: 0x%04x)\n", new_vaddr);
    
    printf("FIFO replacement test passed\n");
}

void test_tlb_lru_replacement() {
    printf("\n=== Testing LRU Replacement ===\n");
    tlb_t tlb;
    initialize_tlb(&tlb);
    tlb.policy = LRU;
    tlb.current_time = 0;
    
    printf("Filling TLB with %d entries...\n", TLB_SIZE);
    for (int i = 0; i < TLB_SIZE; i++) {
        uint16_t vaddr = i << 8;
        printf("Adding entry %d - Virtual Address: 0x%04x, Frame: %d\n", i, vaddr, i);
        tlb_add_entry(&tlb, vaddr, i, 1, 1);
    }
    
    printf("\nTLB state after filling:\n");
    print_tlb_state(&tlb);
    
    // 첫 번째 엔트리 접근
    uint32_t paddr;
    printf("\nAccessing first entry (VA: 0x0000) to update its timestamp\n");
    tlb_lookup(&tlb, 0, &paddr);
    
    printf("TLB state after accessing first entry:\n");
    print_tlb_state(&tlb);
    
    // 새로운 엔트리 추가
    uint16_t new_vaddr = TLB_SIZE << 8;
    printf("\nAdding new entry to trigger LRU replacement - VA: 0x%04x\n", new_vaddr);
    tlb_add_entry(&tlb, new_vaddr, TLB_SIZE, 1, 1);
    
    printf("\nFinal TLB state:\n");
    print_tlb_state(&tlb);
    
    assert(tlb_lookup(&tlb, 0, &paddr) == TLB_HIT);
    printf("Verified: Recently accessed entry still present\n");
    
    printf("LRU replacement test passed\n");
}

void test_tlb_sca_replacement() {
    printf("\n=== Testing Second Chance Algorithm Replacement ===\n");
    tlb_t tlb;
    initialize_tlb(&tlb);
    tlb.policy = SCA;
    
    printf("Filling TLB with %d entries...\n", TLB_SIZE);
    for (int i = 0; i < TLB_SIZE; i++) {
        uint16_t vaddr = i << 8;
        printf("Adding entry %d - Virtual Address: 0x%04x, Frame: %d\n", i, vaddr, i);
        tlb_add_entry(&tlb, vaddr, i, 1, 1);
    }
    
    printf("\nTLB state after filling:\n");
    print_tlb_state(&tlb);
    
    // 몇 개의 엔트리를 접근하여 참조 비트 설정
    uint32_t paddr;
    printf("\nAccessing first two entries to set their reference bits:\n");
    printf("Accessing VA: 0x0000\n");
    tlb_lookup(&tlb, 0, &paddr);
    printf("Accessing VA: 0x0100\n");
    tlb_lookup(&tlb, 1 << 8, &paddr);
    
    printf("\nTLB state after accessing entries:\n");
    print_tlb_state(&tlb);
    
    // 새로운 엔트리 추가
    uint16_t new_vaddr = TLB_SIZE << 8;
    printf("\nAdding new entry to trigger SCA replacement - VA: 0x%04x\n", new_vaddr);
    tlb_add_entry(&tlb, new_vaddr, TLB_SIZE, 1, 1);
    
    printf("\nFinal TLB state:\n");
    print_tlb_state(&tlb);
    
    assert(tlb_lookup(&tlb, 0, &paddr) == TLB_HIT);
    assert(tlb_lookup(&tlb, 1 << 8, &paddr) == TLB_HIT);
    printf("Verified: Recently accessed entries still present\n");
    
    printf("SCA replacement test passed\n");
}

int main() {
    printf("Starting TLB tests...\n");
    
    test_tlb_initialization();
    test_tlb_lookup_hit_miss();
    test_tlb_fifo_replacement();
    test_tlb_lru_replacement();
    test_tlb_sca_replacement();
    
    printf("\nAll TLB tests passed successfully!\n");
    return 0;
}