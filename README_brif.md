실제 메모리를 Array를 구현 -> pfn 계산하는 부분, pfn에서 실제 물리 메모리 계산하는 부분
TLB와 Cache Operation 등, 
Intel - ARM 등 SW TLB가 존재 -> OS가 직접 핸들링하도록 하는 경우도 있었음


1. OS 부팅 시, Free page frame 관리
2. 전체 물리 메모리 크기는 가정, PFN ~ 0에서 시작
3. 사용자 프로세스 초기화 -> 빈 페이지 테이블 할당
4. 사용자 프로세스 실행 => 자식 프로세스에서, 10개의 메모리 주소에 대해서 접근
5. 사용자 프로세스 요청 => OS, msgget 실행 후 메모리 접근 확인
6. OS => 페이지 테이블 확인
   7. 유효 시 페이지 테이블 접근
   8. 유효 X, OS에서는 Page fault 발생 후, Free Page list에서 새로운 Free page Frame을 가지고 옴
9. 페이지 테이블 Lookup
   10. VM 주소를 VM 페이지 번호와 VM 페이지 오프셋 두 부분으로 나눔
   11. MMU -> 페이지 테이블 시작 주소 => 스케줄링 될 때, PTFR을 초기화하는 로직이 필요함.
   12. VM 페이지 번호는 페이지 테이블 인덱스로 사용
   13. 페이지 테이블 인덱스에 페이지 테이블 엔트리 위치
   14. 페이지 테이블 엔트리 내부에는 페이지 프레임 번호와 Flag 저장

# 2단계 페이징
1. 페이지 테이블 엔트리는 대부분의 시간 동안 0
![](2024-os-proj2/asset/2-Level-page-table.png)
2. MMU는 1단계 페이지 테이블을 가리킴
   3. 1단계 엔트리가 NULL => 테이블 X, page fault
   4. 1단계 페이지 테이블 엔트리 페이지 프레임 번호로 채움 => 하나의 프레임을 차지하여, 메모리 동작 구현

# Current TODO
- 일단, Shared_memory를 가지고 페이지 테이블 접근하는 방식으로 할 것임
- Shared_memory 만들었음
- PROJ1에 필요한 메트릭은 전부 전처리문으로 제외
- Child의 메인함수에서, vaddr 접근하는 구문 실행하도록 할 것임
- Parent의 Thread Worker로, 가상 메모리 접근 요청 발생 여부를 polling으로 계속 확인하도록 할 것임. 
- 2-Level-Page Table 구현과 TLB + Caching 구현을 목표로 구현 중임. 

# Physical Memory Implementation
- 하나의 공유 메모리로 잡고, TLB와 Cache 메모리 구현할 생각
- 구현 매개체: 공유 메모리
- 전체 크기: 4MB
  - 페이지 프레임 크기: 1KB
  - 전체 페이지 프레임 수: 4096개

# 가상 메모리 체계 구현
- 주소 공간: 0x0000 ~ 0xFFFF
- 전체 크기: 64KB
- 페이지 프레임 크기 : 1KB
   - 전체 프로세스가 사용할 페이지의 개수: 640개


# 가상 주소 구성

- 오프셋: 10비트